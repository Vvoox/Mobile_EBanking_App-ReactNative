{"ast":null,"code":"var _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.useKey = void 0;\n\nvar React = _interopRequireWildcard(require(\"react\"));\n\nvar keyGenerator = function keyGenerator() {\n  return \"portalize_\".concat(Math.random().toString(36).substr(2, 16), \"-\").concat(Math.random().toString(36).substr(2, 16), \"-\").concat(Math.random().toString(36).substr(2, 16));\n};\n\nvar useKey = function useKey() {\n  var usedKeys = React.useRef([]);\n\n  var generateKey = function generateKey() {\n    var foundUniqueKey = false;\n    var newKey = '';\n    var tries = 0;\n\n    while (!foundUniqueKey && tries < 3) {\n      tries++;\n      newKey = keyGenerator();\n\n      if (!usedKeys.current.includes(newKey)) {\n        foundUniqueKey = true;\n      }\n    }\n\n    if (!foundUniqueKey) {\n      newKey = \"portalize_\".concat(Date.now(), \"_\").concat(Math.floor(Math.random() * 1000));\n    }\n\n    usedKeys.current.push(newKey);\n    return newKey;\n  };\n\n  var removeKey = function removeKey(key) {\n    usedKeys.current = usedKeys.current.filter(function (k) {\n      return k !== key;\n    });\n  };\n\n  return {\n    generateKey: generateKey,\n    removeKey: removeKey\n  };\n};\n\nexports.useKey = useKey;","map":{"version":3,"sources":["useKey.ts"],"names":["keyGenerator","Math","useKey","usedKeys","React","generateKey","foundUniqueKey","newKey","tries","Date","removeKey","k"],"mappings":";;;;;;;AAAA,IAAA,KAAA,GAAA,uBAAA,CAAA,OAAA,CAAA,OAAA,CAAA,CAAA;;AAQA,IAAMA,YAAY,GAAZA,SAAAA,YAAAA,GAA6B;AACjC,SAAA,aAAA,MAAA,CAAoBC,IAAI,CAAJA,MAAAA,GAAAA,QAAAA,CAAAA,EAAAA,EAAAA,MAAAA,CAAAA,CAAAA,EAApB,EAAoBA,CAApB,EAAA,GAAA,EAAA,MAAA,CAEoBA,IAAI,CAAJA,MAAAA,GAAAA,QAAAA,CAAAA,EAAAA,EAAAA,MAAAA,CAAAA,CAAAA,EAFpB,EAEoBA,CAFpB,EAAA,GAAA,EAAA,MAAA,CAIoBA,IAAI,CAAJA,MAAAA,GAAAA,QAAAA,CAAAA,EAAAA,EAAAA,MAAAA,CAAAA,CAAAA,EAJpB,EAIoBA,CAJpB,CAAA;AADF,CAAA;;AASO,IAAMC,MAAM,GAANA,SAAAA,MAAAA,GAAwB;AACnC,MAAMC,QAAQ,GAAGC,KAAK,CAALA,MAAAA,CAAjB,EAAiBA,CAAjB;;AAEA,MAAMC,WAAW,GAAXA,SAAAA,WAAAA,GAA4B;AAChC,QAAIC,cAAc,GAAlB,KAAA;AACA,QAAIC,MAAM,GAAV,EAAA;AACA,QAAIC,KAAK,GAAT,CAAA;;AAEA,WAAO,CAAA,cAAA,IAAmBA,KAAK,GAA/B,CAAA,EAAqC;AAEnCA,MAAAA,KAAK;AACLD,MAAAA,MAAM,GAAGP,YAATO,EAAAA;;AAEA,UAAI,CAACJ,QAAQ,CAARA,OAAAA,CAAAA,QAAAA,CAAL,MAAKA,CAAL,EAAwC;AACtCG,QAAAA,cAAc,GAAdA,IAAAA;AAEH;AAGD;;AAAA,QAAI,CAAJ,cAAA,EAAqB;AACnBC,MAAAA,MAAM,GAAA,aAAA,MAAA,CAAgBE,IAAI,CAApB,GAAgBA,EAAhB,EAAA,GAAA,EAAA,MAAA,CAA8BR,IAAI,CAAJA,KAAAA,CAAWA,IAAI,CAAJA,MAAAA,KAA/CM,IAAoCN,CAA9B,CAANM;AAGFJ;;AAAAA,IAAAA,QAAQ,CAARA,OAAAA,CAAAA,IAAAA,CAAAA,MAAAA;AACA,WAAA,MAAA;AArBF,GAAA;;AAyBA,MAAMO,SAAS,GAATA,SAAAA,SAAAA,CAAY,GAAZA,EAAmC;AACvCP,IAAAA,QAAQ,CAARA,OAAAA,GAAmBA,QAAQ,CAARA,OAAAA,CAAAA,MAAAA,CAAwB,UAAA,CAAA,EAAA;AAAA,aAAOQ,CAAC,KAAR,GAAA;AAA3CR,KAAmBA,CAAnBA;AADF,GAAA;;AAIA,SAAO;AAAEE,IAAAA,WAAW,EAAb,WAAA;AAAeK,IAAAA,SAAS,EAA/B;AAAO,GAAP;AAhCK,CAAA","sourcesContent":["import * as React from 'react';\n\ninterface IUseKey {\n  generateKey(): string;\n  removeKey(key: string): void;\n}\n\n// Generates a random key\nconst keyGenerator = (): string => {\n  return `portalize_${Math.random()\n    .toString(36)\n    .substr(2, 16)}-${Math.random()\n    .toString(36)\n    .substr(2, 16)}-${Math.random().toString(36).substr(2, 16)}`;\n};\n\n// Custom hook that checks for uniqueness and retries if clashes\nexport const useKey = (): IUseKey => {\n  const usedKeys = React.useRef<Array<string>>([]);\n\n  const generateKey = (): string => {\n    let foundUniqueKey = false;\n    let newKey = '';\n    let tries = 0;\n\n    while (!foundUniqueKey && tries < 3) {\n      // limit number of tries to stop endless loop of pain\n      tries++;\n      newKey = keyGenerator();\n\n      if (!usedKeys.current.includes(newKey)) {\n        foundUniqueKey = true;\n      }\n    }\n\n    // will only run if exited while loop without finding a unique key\n    if (!foundUniqueKey) {\n      newKey = `portalize_${Date.now()}_${Math.floor(Math.random() * 1000)}`; // fallback method\n    }\n\n    usedKeys.current.push(newKey);\n    return newKey;\n  };\n\n  // Removes our key to make it 'available' again\n  const removeKey = (key: string): void => {\n    usedKeys.current = usedKeys.current.filter((k) => k !== key);\n  };\n\n  return { generateKey, removeKey };\n};\n"]},"metadata":{},"sourceType":"script"}